---
title: "BOJ(백준) 5254번 Balls"
excerpt:
header:
  overlay_image: https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png
  overlay_filter: linear-gradient(to right, rgba(0, 0, 0, 0.9) 25%, rgba(0, 0, 0, 0))
  teaser: https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png
categories:
  - Baekjoon
tags:
  - [Dev]

toc: true
toc_sticky: true

date: 2024-04-29
last_modified_at: 2024-04-29
---

<https://www.acmicpc.net/problem/5254>

문제를 간단하게 요약하자면 배열 a1, a2, a3, ... an에서 

① 1 <= i < j <= n인 임의의 i, j에 대해 ai ~ aj의 값을 전부 aj로 바꿀때 배열 전체 합의 최대값을 구하고

② 또 임의의 i, j에 대해 ai ~ aj의 값을 전부 ai로 바꿀때의 최대값도 구하는 것이다.

일단 문제를 관찰해보면 ①을 해결하면 ②는 배열을 뒤집어서 똑같은 방법을 사용하면 해결이 가능하다는 것을 알 수 있다.

따라서 ①을 해결할 방법을 생각해보자.

S[a]


AC code
```cpp
#include <bits/stdc++.h>

using namespace std;
int N,M,ord,cnt,t1,t2,c1,c2,c3,T,board[500][500],r,c,wnum,bnum;
int dy[]={1,-1,0,0},dx[]={0,0,1,-1},mul1[]={0,0,1,1},mul2[]={1,0,1,0},mul3[]={0,1,0,1};
char tmp;
vector<vector<int>>sccs,grp;
vector<int>sccnum,vis,sol;
stack<int> s;

int notCal(int n)
{
	if(n<=N) return n+N;
	else return n-N;
}

int tarjan(int loc)
{
	int minord=vis[loc]=++ord;
	s.push(loc);
	for(int i:grp[loc]) {	
		if(!vis[i])minord=min(tarjan(i),minord);
		else if(!sccnum[i])minord=min(vis[i],minord);
	}
	if(minord==vis[loc]) {
		cnt++;
		vector<int> v;
		while(1)
		{
			t1=s.top();
			s.pop();
			v.push_back(t1);
			sccnum[t1]=cnt;
			if(loc==t1) break;
		}
		sccs.push_back(v);
	}
	return minord;
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>T;
	while(T--)
	{
		wnum=bnum=0;
		cin>>r>>c;
		for(int i=0;i<r;i++) for(int k=0;k<c;k++) {
			cin>>tmp;
			if(tmp=='B') {
				bnum++;
				board[i][k]=bnum;
			}
			else if(tmp=='W') {
				wnum++;
				board[i][k]=-1;
			}
			else board[i][k]=0;
		}
		N=bnum*2;
		sccs=vector<vector<int>>(1),
		grp=vector<vector<int>>(2*N+1);
		sccnum=vis=sol=vector<int>(2*N+1);
		ord=cnt=c3=0;
		
		//이 반복문이 핵심 
		for(int a=0;a<r;a++) for(int b=0;b<c;b++) {
			if(board[a][b]>0) {
				int cy=a,cx=b;
				for(int k=0;k<4;k++) {
					int ny=cy+dy[k],nx=cx+dx[k];
					if(ny<0||ny>=r||nx<0||nx>=c||board[ny][nx]!=-1) grp[board[a][b]+(N/2)*mul1[k]+N*mul3[k]].push_back(notCal(board[a][b]+(N/2)*mul1[k]+N*mul3[k]));
				}
			} else if(board[a][b]==-1) {
				int cy=a,cx=b;	
				for(int k=0;k<4;k++) {
					int ny=cy+dy[k],nx=cx+dx[k];
					if(ny<0||ny>=r||nx<0||nx>=c||board[ny][nx]<1) continue;
					for(int j=0;j<4;j++) {
						int nny=cy+dy[j],nnx=cx+dx[j];
						if(nny==ny&&nnx==nx) continue;
						if(nny<0||nny>=r||nnx<0||nnx>=c||board[nny][nnx]<1) continue;
						grp[board[ny][nx]+(N/2)*mul1[k]+N*mul2[k]].push_back(board[nny][nnx]+(N/2)*mul1[j]+N*mul3[j]);
					}
				}
			}
		}
		
		for(int i=1;i<=2*N;i++)if(!vis[i])tarjan(i);
		vector<int>ind(cnt+1);
		for(int i=1;i<=2*N;i++)for(int k:grp[i]) {
			if(sccnum[i]==sccnum[k])continue;
			ind[sccnum[k]]++;
		}
		queue<int> q;
		for(int i=1;i<=cnt;i++)if(!ind[i])q.push(i);
		while(!q.empty())
		{
			t1=q.front();
			q.pop();
			c1=c2=0;
			for(int i:sccs[t1]) {
				if(sol[i]==1)c1=1;
				else if(sol[i]==-1)c2=1;
				for(int k:grp[i]) {
					ind[sccnum[k]]--;
					if(!ind[sccnum[k]])q.push(sccnum[k]);
				}
			}
			if(c1&&c2) {
				c3=1;
				break;
			}
			if(!c1)c1=-1;
			for(int i:sccs[t1]) {
				sol[i]=c1;
				if(sol[i]==sol[notCal(i)]) {
					c3=1;
					break;
				}
				sol[notCal(i)]=c1*-1;
			}
			if(c3)break;
		}
		if(!c3&&wnum==bnum*2)cout<<"YES\n";
		else cout<<"NO\n";
	}
}
```